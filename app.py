# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jQG3n6GIiuLsbVFnmzpv2pc40-FIX2Pu
"""

"""
Hotel Booking Cancellation Prediction - Flask Backend
app.py - CORRECTED VERSION
"""

from flask import Flask, render_template, request, jsonify
import joblib
import numpy as np
import pandas as pd
import traceback
import json

app = Flask(__name__)

# ============================================
# LOAD THE TRAINED MODEL
# ============================================
try:
    model = joblib.load('xgboost_final_model.pkl')
    print("‚úÖ Model loaded successfully!")
except Exception as e:
    print(f"‚ùå Error loading model: {e}")
    model = None

import json

# Load scaler
try:
    scaler = joblib.load('scaler.pkl')
    print("‚úÖ Scaler loaded successfully!")
except Exception as e:
    print(f"‚ùå Error loading scaler: {e}")
    scaler = None

# Load numeric column names
try:
    with open('numeric_columns.json', 'r') as f:
        NUMERIC_COLS = json.load(f)
    print(f"‚úÖ Loaded {len(NUMERIC_COLS)} numeric columns for scaling")
except Exception as e:
    print(f"‚ùå Error loading numeric columns: {e}")
    NUMERIC_COLS = []

# ============================================
# DEFINE FEATURE NAMES
# ============================================
FEATURE_NAMES = ['lead_time', 'arrival_date_year', 'arrival_date_month', 'arrival_date_week_number', 'arrival_date_day_of_month', 'stays_in_weekend_nights', 'stays_in_week_nights', 'adults', 'children', 'babies', 'is_repeated_guest', 'previous_cancellations', 'previous_bookings_not_canceled', 'booking_changes', 'agent', 'company', 'days_in_waiting_list', 'adr', 'required_car_parking_spaces', 'total_of_special_requests', 'total_guests', 'total_nights', 'is_family', 'hotel_Resort Hotel', 'meal_FB', 'meal_HB', 'meal_SC', 'meal_Undefined', 'market_segment_Complementary', 'market_segment_Corporate', 'market_segment_Direct', 'market_segment_Groups', 'market_segment_Offline TA/TO', 'market_segment_Online TA', 'market_segment_Undefined', 'distribution_channel_Direct', 'distribution_channel_GDS', 'distribution_channel_TA/TO', 'distribution_channel_Undefined', 'reserved_room_type_B', 'reserved_room_type_C', 'reserved_room_type_D', 'reserved_room_type_E', 'reserved_room_type_F', 'reserved_room_type_G', 'reserved_room_type_H', 'reserved_room_type_L', 'reserved_room_type_P', 'deposit_type_Non Refund', 'deposit_type_Refundable', 'customer_type_Group', 'customer_type_Transient', 'customer_type_Transient-Party', 'stay_duration_category_Medium', 'stay_duration_category_Long', 'season_Spring', 'season_Summer', 'season_Winter', 'country_AGO', 'country_AIA', 'country_ALB', 'country_AND', 'country_ARE', 'country_ARG', 'country_ARM', 'country_ASM', 'country_ATA', 'country_ATF', 'country_AUS', 'country_AUT', 'country_AZE', 'country_BDI', 'country_BEL', 'country_BEN', 'country_BFA', 'country_BGD', 'country_BGR', 'country_BHR', 'country_BHS', 'country_BIH', 'country_BLR', 'country_BOL', 'country_BRA', 'country_BRB', 'country_BWA', 'country_CAF', 'country_CHE', 'country_CHL', 'country_CHN', 'country_CIV', 'country_CMR', 'country_CN', 'country_COL', 'country_COM', 'country_CPV', 'country_CRI', 'country_CUB', 'country_CYM', 'country_CYP', 'country_CZE', 'country_DEU', 'country_DJI', 'country_DMA', 'country_DNK', 'country_DOM', 'country_DZA', 'country_ECU', 'country_EGY', 'country_ESP', 'country_EST', 'country_ETH', 'country_FIN', 'country_FJI', 'country_FRA', 'country_FRO', 'country_GAB', 'country_GBR', 'country_GEO', 'country_GGY', 'country_GHA', 'country_GIB', 'country_GLP', 'country_GNB', 'country_GRC', 'country_GTM', 'country_GUY', 'country_HKG', 'country_HND', 'country_HRV', 'country_HUN', 'country_IDN', 'country_IMN', 'country_IND', 'country_IRL', 'country_IRN', 'country_IRQ', 'country_ISL', 'country_ISR', 'country_ITA', 'country_JAM', 'country_JEY', 'country_JOR', 'country_JPN', 'country_KAZ', 'country_KEN', 'country_KHM', 'country_KIR', 'country_KNA', 'country_KOR', 'country_KWT', 'country_LAO', 'country_LBN', 'country_LBY', 'country_LCA', 'country_LIE', 'country_LKA', 'country_LTU', 'country_LUX', 'country_LVA', 'country_MAC', 'country_MAR', 'country_MCO', 'country_MDG', 'country_MDV', 'country_MEX', 'country_MKD', 'country_MLI', 'country_MLT', 'country_MMR', 'country_MNE', 'country_MOZ', 'country_MRT', 'country_MUS', 'country_MWI', 'country_MYS', 'country_MYT', 'country_NAM', 'country_NCL', 'country_NGA', 'country_NIC', 'country_NLD', 'country_NOR', 'country_NPL', 'country_NZL', 'country_OMN', 'country_PAK', 'country_PAN', 'country_PER', 'country_PHL', 'country_PLW', 'country_POL', 'country_PRI', 'country_PRT', 'country_PRY', 'country_PYF', 'country_QAT', 'country_ROU', 'country_RUS', 'country_RWA', 'country_SAU', 'country_SDN', 'country_SEN', 'country_SGP', 'country_SLE', 'country_SLV', 'country_SMR', 'country_SRB', 'country_STP', 'country_SUR', 'country_SVK', 'country_SVN', 'country_SWE', 'country_SYC', 'country_SYR', 'country_TGO', 'country_THA', 'country_TJK', 'country_TMP', 'country_TUN', 'country_TUR', 'country_TWN', 'country_TZA', 'country_UGA', 'country_UKR', 'country_UMI', 'country_URY', 'country_USA', 'country_UZB', 'country_VEN', 'country_VGB', 'country_VNM', 'country_ZAF', 'country_ZMB', 'country_ZWE']

# Month to number mapping
MONTH_MAP = {
    'January': 1, 'February': 2, 'March': 3, 'April': 4,
    'May': 5, 'June': 6, 'July': 7, 'August': 8,
    'September': 9, 'October': 10, 'November': 11, 'December': 12
}

# Season mapping
SEASON_MAP = {
    'December': 'Winter', 'January': 'Winter', 'February': 'Winter',
    'March': 'Spring', 'April': 'Spring', 'May': 'Spring',
    'June': 'Summer', 'July': 'Summer', 'August': 'Summer',
    'September': 'Autumn', 'October': 'Autumn', 'November': 'Autumn'
}

# ============================================
# HOME PAGE
# ============================================
@app.route('/')
def home():
    return render_template('index.html')

# ============================================
# PREDICTION API
# ============================================
@app.route('/predict', methods=['POST'])
def predict():
    try:
        data = request.json

        print("\n" + "="*70)
        print("üîç PREDICTION REQUEST")
        print("="*70)
        print(f"Received data: {data}")

        # Create feature array (all zeros initially)
        features = np.zeros((1, len(FEATURE_NAMES)))

        # ============================================
        # 1. EXTRACT & CALCULATE BASIC VALUES
        # ============================================
        adults = float(data.get('adults', 2))
        children = float(data.get('children', 0))
        babies = float(data.get('babies', 0))
        weekend_nights = float(data.get('stays_in_weekend_nights', 0))
        week_nights = float(data.get('stays_in_week_nights', 0))

        # Calculate derived features
        total_guests = adults + children + babies
        total_nights = weekend_nights + week_nights
        is_family = 1 if (children + babies) > 0 else 0

        # Determine stay duration category
        if total_nights < 3:
            stay_category = None  # "Short" is reference category
        elif total_nights < 7:
            stay_category = "Medium"
        else:
            stay_category = "Long"

        # Get season from month
        arrival_month = data.get('arrival_date_month', 'July')
        season = SEASON_MAP.get(arrival_month, 'Summer')

        # Convert month to number
        arrival_month_num = MONTH_MAP.get(arrival_month, 7)

        # ============================================
        # 2. FILL NUMERIC FEATURES
        # ============================================
        numeric_features = {
            'lead_time': float(data.get('lead_time', 0)),
            'arrival_date_year': float(data.get('arrival_date_year', 2024)),
            'arrival_date_month': float(arrival_month_num),
            'arrival_date_week_number': float(data.get('arrival_date_week_number', 1)),
            'arrival_date_day_of_month': float(data.get('arrival_date_day_of_month', 15)),
            'stays_in_weekend_nights': weekend_nights,
            'stays_in_week_nights': week_nights,
            'adults': adults,
            'children': children,
            'babies': babies,
            'is_repeated_guest': int(data.get('is_repeated_guest', 0)),
            'previous_cancellations': float(data.get('previous_cancellations', 0)),
            'previous_bookings_not_canceled': float(data.get('previous_bookings_not_canceled', 0)),
            'booking_changes': float(data.get('booking_changes', 0)),
            'agent': float(data.get('agent', 0)),
            'company': float(data.get('company', 0)),
            'days_in_waiting_list': float(data.get('days_in_waiting_list', 0)),
            'adr': float(data.get('adr', 100)),
            'required_car_parking_spaces': float(data.get('required_car_parking_spaces', 0)),
            'total_of_special_requests': float(data.get('total_of_special_requests', 0)),
            'total_guests': total_guests,
            'total_nights': total_nights,
            'is_family': is_family
        }

        # Fill numeric features
        for feat_name, value in numeric_features.items():
            if feat_name in FEATURE_NAMES:
                idx = FEATURE_NAMES.index(feat_name)
                features[0, idx] = value

        # ============================================
        # 3. FILL ONE-HOT ENCODED FEATURES
        # ============================================

        # Hotel type
        hotel = data.get('hotel', 'Resort Hotel')
        hotel_col = f"hotel_{hotel}"
        if hotel_col in FEATURE_NAMES:
            features[0, FEATURE_NAMES.index(hotel_col)] = 1

        # Meal
        meal = data.get('meal', 'BB')
        meal_col = f"meal_{meal}"
        if meal_col in FEATURE_NAMES:
            features[0, FEATURE_NAMES.index(meal_col)] = 1

        # Market segment
        market = data.get('market_segment', 'Online TA')
        market_col = f"market_segment_{market}"
        if market_col in FEATURE_NAMES:
            features[0, FEATURE_NAMES.index(market_col)] = 1

        # Distribution channel
        channel = data.get('distribution_channel', 'TA/TO')
        channel_col = f"distribution_channel_{channel}"
        if channel_col in FEATURE_NAMES:
            features[0, FEATURE_NAMES.index(channel_col)] = 1

        # Reserved room type
        room = data.get('reserved_room_type', 'A')
        room_col = f"reserved_room_type_{room}"
        if room_col in FEATURE_NAMES:
            features[0, FEATURE_NAMES.index(room_col)] = 1

        # Deposit type
        deposit = data.get('deposit_type', 'No Deposit')
        deposit_col = f"deposit_type_{deposit}"
        if deposit_col in FEATURE_NAMES:
            features[0, FEATURE_NAMES.index(deposit_col)] = 1

        # Customer type
        customer = data.get('customer_type', 'Transient')
        customer_col = f"customer_type_{customer}"
        if customer_col in FEATURE_NAMES:
            features[0, FEATURE_NAMES.index(customer_col)] = 1

        # Stay duration category
        if stay_category:
            stay_col = f"stay_duration_category_{stay_category}"
            if stay_col in FEATURE_NAMES:
                features[0, FEATURE_NAMES.index(stay_col)] = 1

        # Season
        season_col = f"season_{season}"
        if season_col in FEATURE_NAMES:
            features[0, FEATURE_NAMES.index(season_col)] = 1

        # Country
        country = data.get('country', 'PRT')
        country_col = f"country_{country}"
        if country_col in FEATURE_NAMES:
            features[0, FEATURE_NAMES.index(country_col)] = 1

        # ============================================
        # 4. DEBUG: PRINT NON-ZERO FEATURES
        # ============================================
        non_zero_features = []
        for i, feat_name in enumerate(FEATURE_NAMES):
            if features[0, i] != 0:
                non_zero_features.append(f"{feat_name}: {features[0, i]}")

        print(f"\nüìä Non-zero features ({len(non_zero_features)}):")
        for feat in non_zero_features[:20]:
            print(f"   ‚Ä¢ {feat}")
        if len(non_zero_features) > 20:
            print(f"   ... and {len(non_zero_features) - 20} more")

        # ============================================
        # 5. SCALE ONLY THE NUMERIC FEATURES
        # ============================================
        if scaler is not None and len(NUMERIC_COLS) > 0:
            print("\nüîß Scaling numeric features...")

            # Get indices of numeric columns
            numeric_indices = []
            for col in NUMERIC_COLS:
                if col in FEATURE_NAMES:
                    numeric_indices.append(FEATURE_NAMES.index(col))

            # Extract numeric features
            numeric_features_array = features[0, numeric_indices].reshape(1, -1)

            # Scale them
            numeric_features_scaled = scaler.transform(numeric_features_array)

            # Put scaled values back
            for i, idx in enumerate(numeric_indices):
                features[0, idx] = numeric_features_scaled[0, i]

            print(f"‚úÖ Scaled {len(numeric_indices)} numeric features")
        else:
            print("‚ö†Ô∏è WARNING: No scaling applied!")

        # Now features is ready for prediction
        features_final = features

        # ============================================
        # 6. MAKE PREDICTION
        # ============================================
        prediction = model.predict(features_final)[0]
        probabilities = model.predict_proba(features_final)[0]
        prob_canceled = probabilities[1]
        prob_not_canceled = probabilities[0]

        print(f"\nüéØ PREDICTION RESULT:")
        print(f"   Prediction: {prediction} ({'Canceled' if prediction == 1 else 'Not Canceled'})")
        print(f"   Prob[Not Canceled]: {prob_not_canceled:.4f} ({prob_not_canceled*100:.2f}%)")
        print(f"   Prob[Canceled]: {prob_canceled:.4f} ({prob_canceled*100:.2f}%)")

        # Determine risk level
        if prob_canceled >= 0.7:
            risk_level = "High"
        elif prob_canceled >= 0.4:
            risk_level = "Medium"
        else:
            risk_level = "Low"

        print(f"   Risk Level: {risk_level}")
        print("="*70 + "\n")

        # ============================================
        # 7. PREPARE RESPONSE
        # ============================================
        result = {
            'prediction': int(prediction),
            'probability': float(prob_canceled),
            'status': 'Canceled' if prediction == 1 else 'Not Canceled',
            'confidence': f'{prob_canceled * 100:.2f}%' if prediction == 1 else f'{prob_not_canceled * 100:.2f}%',
            'risk_level': risk_level,
            'prob_not_canceled': float(prob_not_canceled),
            'prob_canceled': float(prob_canceled)
        }

        return jsonify(result)

    except Exception as e:
        print(f"\n‚ùå ERROR IN PREDICTION:")
        print(traceback.format_exc())
        return jsonify({'error': str(e)}), 500

# ============================================
# BATCH PREDICTION (Optional)
# ============================================
@app.route('/batch_predict', methods=['POST'])
def batch_predict():
    try:
        file = request.files.get('file')
        if not file:
            return jsonify({'error': 'No file uploaded'}), 400

        df = pd.read_csv(file)
        predictions = model.predict(df)
        probabilities = model.predict_proba(df)[:, 1]

        df['prediction'] = predictions
        df['cancellation_probability'] = probabilities

        results = df.to_dict('records')

        return jsonify({
            'success': True,
            'total_bookings': len(df),
            'predicted_cancellations': int(predictions.sum()),
            'results': results[:100]
        })

    except Exception as e:
        return jsonify({'error': str(e)}), 500

# ============================================
# MODEL INFO
# ============================================
@app.route('/model_info')
def model_info():
    try:
        info = {
            'model_type': str(type(model).__name__),
            'features_count': len(FEATURE_NAMES),
            'model_loaded': model is not None
        }
        return jsonify(info)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# ============================================
# RUN APP
# ============================================
import os

if __name__ == "__main__":
    print("="*70)
    print("üè® Hotel Booking Cancellation Prediction System")
    print("="*70)
    print("‚úÖ Model loaded with", len(FEATURE_NAMES), "features")
    print("üöÄ Starting Flask server...")
    print("="*70)

    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port)
